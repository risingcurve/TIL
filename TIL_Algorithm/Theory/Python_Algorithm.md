**파이썬**  
파이썬에 대한 이해  
파이썬 문법  
__인덴트  
__네이밍 컨벤션  
__타입 힌트  
__리스트 컴프리헨션  
__제너레이터  
__range  
__enumerate 
__// 나눗셈 연산자  
__print  
__pass  
__locals  
코딩 스타일  
__변수명과 주석  
__리스트 컴프리헨션  
__구글 파이썬 스타일 가이드

**빅오, 자료형**  
빅오  
__상한과 최악  
__분할 상환 분석  
__병렬화  
자료형  
__파이썬 자료형  
__원시 타입  
__객체

**리스트, 딕셔너리**  
리스트  
__리스트의 활용 방법  
__리스트의 특징  
딕셔너리  
__딕셔너리의 활용 방법  
__딕셔너리 모듈

**문자열 조작**  
[문제]_01 유효한 팰린드롬  
[문제]_02 문자열 뒤집기  
[문제]_03 로그 파일 재정렬  
[문제]_04 가장 흔한 단어  
[문제]_05 그룹 애너그램  
여러 가지 정렬 방법  
[문제]_06 가장 긴 팰린드롬 부분 문자열  
유니코드와 UTF-8

**[선형 자료구조]**

**배열**  
[문제]_07 두 수의 합  
[문제]_08 빗물 트래핑  
[문제]_09 세 수의 합  
[문제]_10 배열 파티션 I  
[문제]_11 자신을 제외한 배열의 곱  
[문제]_12 주식을 사고팔기 가장 좋은 시점

**연결 리스트**  
[문제]_13 팰린드롬 연결 리스트  
[문제]_14 두 정렬 리스트의 병합  
[문제]_15 역순 연결 리스트  
[문제]_16 두 수의 덧셈  
[문제]_17 페어의 노드 스왑  
[문제]_18 홀짝 연결 리스트  
[문제]_19 역순 연결 리스트 II

**스택, 큐**  
스택  
__연결 리스트를 이용한 스택 ADT 구현  
[문제]_20 유효한 괄호  
[문제]_21 중복 문자 제거  
[문제]_22 일일 온도  
큐  
[문제]_23 큐를 이용한 스택 구현  
[문제]_24 스택을 이용한 큐 구현  
[문제]_25 원형 큐 디자인

**데크, 우선순위 큐**  
데크  
[문제]_26 원형 데크 디자인  
우선순위 큐  
[문제]_27 k개 정렬 리스트 병합

**해시 테이블**  
해시  
__생일 문제  
__비둘기집 원리  
__로드 팩터  
__해시 함수  
충돌  
__개별 체이닝  
__오픈 어드레싱  
__언어별 해시 테이블 구현 방식  
[문제]_28 해시맵 디자인  
[문제]_29 보석과 돌  
[문제]_30 중복 문자 없는 가장 긴 부분 문자열  
[문제]_31 상위 K 빈도 요소

**[비선형 자료구조]**

**그래프**  
오일러 경로  
해밀턴 경로  
그래프 순회  
__DFS(깊이 우선 탐색)  
__BFS(너비 우선 탐색)  
백트래킹  
제약 충족 문제  
[문제]_32 섬의 개수  
[문제]_33 전화 번호 문자 조합  
[문제]_34 순열  
[문제]_35 조합  
[문제]_36 조합의 합  
[문제]_37 부분 집합  
[문제]_38 일정 재구성  
[문제]_39 코스 스케줄

**최단 경로 문제**  
[문제]_40 네트워크 딜레이 타임  
[문제]_41 K 경유지 내 가장 저렴한 항공권

**트리**  
트리의 각 명칭  
그래프 vs 트리  
이진 트리  
[문제]_42 이진 트리의 최대 깊이  
[문제]_43 이진 트리의 직경  
[문제]_44 가장 긴 동일 값의 경로  
[문제]_45 이진 트리 반전  
[문제]_46 두 이진 트리 병합  
[문제]_47 이진 트리 직렬화 & 역직렬화  
[문제]_48 균형 이진 트리  
[문제]_49 최소 높이 트리  
이진 탐색 트리(BST)  
__자가 균형 이진 탐색 트리  
[문제]_50 정렬된 배열의 이진 탐색 트리 변환  
[문제]_51 이진 탐색 트리(BST)를 더 큰 수 합계 트리로  
[문제]_52 이진 탐색 트리(BST) 합의 범위  
[문제]_53 이진 탐색 트리(BST) 노드 간 최소 거리  
트리 순회  
[문제]_54 전위, 중위 순회 결과로 이진 트리 구축

**힙**  
힙 연산  
__삽입  
__추출  
[문제]_55 배열의 K번째 큰 요소

**트라이**  
[문제]_56 트라이 구현  
[문제]_57 팰린드롬 페어

**[알고리즘]**

**정렬**  
버블 정렬  
병합 정렬  
퀵 정렬  
안정 정렬 vs 불안정 정렬  
[문제]_58 리스트 정렬  
[문제]_59 구간 병합  
[문제]_60 삽입 정렬 리스트  
[문제]_61 가장 큰 수  
[문제]_62 유효한 애너그램  
[문제]_63 색 정렬  
[문제]_64 원점에 K번째로 가까운 점

**이진 검색**  
[문제]_65 이진 검색  
[문제]_66 회전 정렬된 배열 검색  
[문제]_67 두 배열의 교집합  
[문제]_68 두 수의 합 II  
[문제]_69 2D 매트릭스 검색 II

**비트 조작**  
부울 연산자  
비트 연산자  
비트 조작 퀴즈  
__자릿수 제한 비트 연산  
2의 보수  
__2의 보수 숫자 포맷  
__2의 보수 수학 연산  
__비트 연산자 NOT  
[문제]_70 싱글 넘버  
[문제]_71 해밍 거리  
[문제]_72 두 정수의 합  
[문제]_73 UTF-8 검증  
[문제]_74 1비트의 개수

**슬라이딩 윈도우**  
[문제]_75 최대 슬라이딩 윈도우  
[문제]_76 부분 문자열이 포함된 최소 윈도우  
[문제]_77 가장 긴 반복 문자 대체

**그리디 알고리즘**  
배낭 문제  
동전 바꾸기 문제  
가장 큰 합  
[문제]_78 주식을 사고 팔기 가장 좋은 시점 II  
[문제]_79 키에 따른 대기열 재구성  
[문제]_80 태스크 스케줄러  
[문제]_81 주유소  
[문제]_82 쿠키 부여

**분할 정복**  
[문제]_83 과반수 엘리먼트  
[문제]_84 괄호를 삽입하는 여러 가지 방법

**다이나믹 프로그래밍**  
최적 부분 구조  
중복된 하위 문제들  
다이나믹 프로그래밍 방법론  
[문제]_85 피보나치 수  
0-1 배낭 문제  
[문제]_86 최대 서브 배열  
[문제]_87 계단 오르기  
[문제]_88 집 도둑

---

파이썬에서 빅오

빅오(Big-O)는 알고리즘이 입력 크기에 대해 어떻게 동작하는지를 나타내는 시간 복잡도 분석의 한 가지 방법입니다. 파이썬에서도 이를 적용할 수 있습니다.

예를 들어, 다음은 파이썬에서 빅오 표기법을 사용하여 특정 함수의 시간 복잡도를 표현하는 방법입니다.

1. O(1): 상수 시간 복잡도. 입력의 크기와 상관없이 일정한 시간이 소요됩니다. 예를 들어, 리스트의 첫 번째 요소를 가져오는 연산은 O(1) 시간이 소요됩니다.

2. O(log n): 로그 시간 복잡도. 입력의 크기가 커질수록 시간이 증가하지만, 증가하는 속도가 느립니다. 이진 검색과 같은 작업이 O(log n) 시간이 소요됩니다.

3. O(n): 선형 시간 복잡도. 입력의 크기에 비례하여 시간이 선형적으로 증가합니다. 예를 들어, 리스트를 선형 검색하는 작업은 O(n) 시간이 소요됩니다.

4. O(n log n): 선형 로그 시간 복잡도. 입력의 크기가 커질수록 시간이 빠르게 증가하지만, 증가하는 속도는 로그 함수에 비례합니다. 병합 정렬과 같은 작업이 O(n log n) 시간이 소요됩니다.

5. O(n^2): 이차 시간 복잡도. 입력의 크기에 제곱에 비례하여 시간이 증가합니다. 버블 정렬과 같은 작업이 O(n^2) 시간이 소요됩니다.

6. O(2^n): 지수 시간 복잡도. 입력의 크기가 커질수록 시간이 기하급수적으로 증가합니다. 부분집합 생성과 같은 작업이 O(2^n) 시간이 소요됩니다.

이외에도 다양한 시간 복잡도가 있지만, 위에서 소개한 것들이 파이썬에서 자주 사용됩니다. 파이썬에서는 이러한 빅오 시간 복잡도를 고려하여 알고리즘을 작성하고, 프로그램을 최적화할 수 있습니다.





# 파이썬에서 자료형

파이썬은 동적 타이핑(dynamic typing) 언어로, 변수의 타입이 실행 시간에 결정됩니다. 파이썬에서 제공하는 자료형은 다음과 같습니다.

1. 숫자형(Number): 정수(int), 실수(float), 복소수(complex) 등의 숫자형 자료형이 있습니다.

2. 문자열(String): 문자열(str)은 여러 개의 문자를 모아 놓은 자료형입니다.

3. 불(Bool): 참(True) 또는 거짓(False) 값을 가지는 불(bool) 자료형이 있습니다.

4. 리스트(List): 여러 개의 데이터를 모아 놓은 자료형입니다. 대괄호([])로 표현하며, 원소들은 쉼표로 구분됩니다.

5. 튜플(Tuple): 리스트와 유사하지만, 원소를 수정할 수 없는 자료형입니다. 소괄호(())로 표현하며, 원소들은 쉼표로 구분됩니다.

6. 집합(Set): 중복을 허용하지 않는 자료형으로, 순서가 없습니다. 중괄호({})로 표현하며, 원소들은 쉼표로 구분됩니다.

7. 딕셔너리(Dictionary): 키와 값으로 이루어진 자료형입니다. 중괄호({})로 표현하며, 키와 값은 콜론(:)으로 구분하고, 항목들은 쉼표로 구분됩니다.

파이썬에서는 이외에도 다양한 자료형이 제공되지만, 위에서 소개한 것들이 가장 기본적이고 많이 사용됩니다. 이러한 자료형을 적절히 활용하여 파이썬 프로그래밍을 수행할 수 있습니다.





# 파이썬 자료구조

파이썬에서는 다양한 자료구조를 제공합니다. 각 자료구조의 특징과 사용 방법을 살펴보겠습니다.

1. 리스트(List)

리스트는 순서가 있는 데이터의 집합으로, 대괄호([])로 표현합니다. 원소들은 쉼표로 구분합니다. 리스트는 수정이 가능하며, 인덱싱과 슬라이싱을 통해 데이터를 접근할 수 있습니다.

예시:

```python
a = [1, 2, 3, 4, 5]  # 리스트 생성
print(a)  # [1, 2, 3, 4, 5]
print(a[0])  # 1
print(a[2:4])  # [3, 4]
a[1] = 10  # 리스트 값 수정
print(a)  # [1, 10, 3, 4, 5]
```

2. 튜플(Tuple)

튜플은 리스트와 유사하지만, 수정이 불가능합니다. 소괄호(())로 표현합니다.

예시:

```python
a = (1, 2, 3)  # 튜플 생성
print(a)  # (1, 2, 3)
print(a[0])  # 1
a[1] = 10  # TypeError: 'tuple' object does not support item assignment
```

3. 집합(Set)

집합은 중복을 허용하지 않는 데이터의 집합으로, 중괄호({})로 표현합니다.

예시:

```python
a = {1, 2, 3}  # 집합 생성
print(a)  # {1, 2, 3}
b = {3, 4, 5}
print(a.union(b))  # {1, 2, 3, 4, 5}
```

4. 딕셔너리(Dictionary)

딕셔너리는 키-값 쌍으로 이루어진 데이터의 집합으로, 중괄호({})로 표현합니다. 키를 이용해 값을 접근할 수 있습니다.

예시:

```python
a = {'apple': 1000, 'banana': 2000, 'orange': 1500}  # 딕셔너리 생성
print(a)  # {'apple': 1000, 'banana': 2000, 'orange': 1500}
print(a['apple'])  # 1000
a['banana'] = 2500  # 딕셔너리 값 수정
print(a)  # {'apple': 1000, 'banana': 2500, 'orange': 1500}
```

6. 큐(Queue)

큐는 데이터를 넣고(enqueue) 꺼내는(dequeue) 작업이 가능한 자료구조입니다. 먼저 넣은 데이터가 먼저 꺼내지는 선입선출(FIFO) 방식을 따릅니다. 파이썬에서는 collections 모듈의 deque 클래스를 사용하여 구현할 수 있습니다.

예시:

```python
from collections import deque

a = deque([1, 2, 3])  # 큐 생성
a.append(4)  # enqueue
print(a)  # deque([1, 2, 3, 4])
a.popleft()  # dequeue
print(a)  # deque([2, 3, 4])
```

7. 힙(Heap)

힙은 최솟값 또는 최댓값을 빠르게 찾아내기 위한 이진트리 기반의 자료구조입니다. 파이썬에서는 heapq 모듈을 사용하여 구현할 수 있습니다.

예시:

```python
import heapq

a = [3, 1, 4, 1, 5, 9, 2, 6, 5]
heapq.heapify(a)  # 힙 생성
print(a)  # [1, 1, 2, 6, 5, 9, 4, 3, 5]
print(heapq.heappop(a))  # 1 (최솟값)
print(a)  # [1, 3, 2, 6, 5, 9, 4, 5]
```

8. 그래프(Graph)

그래프는 정점(Vertex)과 간선(Edge)으로 구성된 자료구조입니다. 파이썬에서는 dict 타입을 사용하여 구현할 수 있습니다.

예시:

```python
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'E'],
    'D': ['B'],
    'E': ['C']
}

print(graph['A'])  # ['B', 'C']
```

위와 같이 파이썬에서는 다양한 자료구조를 제공하며, 이를 적절하게 활용하여 프로그램을 작성할 수 있습니다.

9. 해시테이블(Hash Table)

해시테이블은 키-값(Key-Value) 쌍으로 데이터를 저장하는 자료구조입니다. 키를 이용하여 값을 검색하거나 삽입, 삭제하는데 매우 효율적입니다. 파이썬에서는 딕셔너리(Dictionary) 타입을 사용하여 구현할 수 있습니다.

예시:

```python
hash_table = {}
hash_table['one'] = 1
hash_table['two'] = 2
hash_table['three'] = 3

print(hash_table)  # {'one': 1, 'two': 2, 'three': 3}
print(hash_table['one'])  # 1
```

10. 트라이(Trie)

트라이는 문자열 검색에 효율적인 자료구조입니다. 문자열의 글자들을 노드로 나타내어 저장하는 트리 구조입니다. 파이썬에서는 별도의 모듈 없이 딕셔너리를 사용하여 구현할 수 있습니다.

예시:

```python
trie = {}

def insert(string):
    cur = trie
    for char in string:
        if char not in cur:
            cur[char] = {}
        cur = cur[char]
    cur['*'] = True

insert('hello')
insert('world')

print(trie)  # {'h': {'e': {'l': {'l': {'o': {'*': True}}}}}, 'w': {'o': {'r': {'l': {'d': {'*': True}}}}}}
```

좀 더 알려줘

11. 스택(Stack)

스택은 데이터를 넣고(push) 꺼내는(pop) 작업이 가능한 자료구조입니다. 마지막에 넣은 데이터가 가장 먼저 꺼내지는 후입선출(LIFO) 방식을 따릅니다. 파이썬에서는 리스트를 사용하여 스택을 구현할 수 있습니다.

예시:

```python
stack = []

stack.append(1)  # push
stack.append(2)
stack.append(3)
print(stack)  # [1, 2, 3]

print(stack.pop())  # 3 (pop)
print(stack)  # [1, 2]
```

12. 세트(Set)

세트는 중복되지 않은 데이터를 저장하는 자료구조입니다. 파이썬에서는 set 타입을 사용하여 구현할 수 있습니다.

예시:

```python
set1 = set([1, 2, 3])
set2 = set([2, 3, 4])

print(set1 & set2)  # {2, 3} (교집합)
print(set1 | set2)  # {1, 2, 3, 4} (합집합)
print(set1 - set2)  # {1} (차집합)
```

13. 덱(Deque)

덱은 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조입니다. 파이썬에서는 collections 모듈의 deque 클래스를 사용하여 구현할 수 있습니다.

예시:

```python
from collections import deque

d = deque([1, 2, 3])

d.appendleft(0)  # 왼쪽에 추가
print(d)  # deque([0, 1, 2, 3])

d.extend([4, 5])  # 오른쪽에 추가
print(d)  # deque([0, 1, 2, 3, 4, 5])

d.pop()  # 오른쪽에서 꺼냄
print(d)  # deque([0, 1, 2, 3, 4])
```

14. OrderedDict

OrderedDict는 딕셔너리와 비슷하지만, 키-값 쌍이 추가된 순서를 기억하는 자료구조입니다. 파이썬에서는 collections 모듈의 OrderedDict 클래스를 사용하여 구현할 수 있습니다.

예시:

```python
from collections import OrderedDict

d = OrderedDict()

d['banana'] = 3
d['apple'] = 4
d['pear'] = 1

print(d)  # OrderedDict([('banana', 3), ('apple', 4), ('pear', 1)])
```

파이썬에서 제공하는 다양한 자료구조를 적절하게 사용하여, 프로그램의 효율성을 높일 수 있습니다.

좀 더 알려줘

15. 힙(Heap)

힙은 부모 노드와 자식 노드 간의 관계를 이용하여 정렬된 트리를 구현하는 자료구조입니다. 최소 힙(min heap)에서는 부모 노드의 값이 자식 노드의 값보다 작거나 같고, 최대 힙(max heap)에서는 부모 노드의 값이 자식 노드의 값보다 크거나 같습니다. 파이썬에서는 heapq 모듈을 사용하여 힙을 구현할 수 있습니다.

예시:

```python
import heapq

heap = []
heapq.heappush(heap, 3)
heapq.heappush(heap, 1)
heapq.heappush(heap, 2)
print(heap)  # [1, 3, 2]

print(heapq.heappop(heap))  # 1
print(heap)  # [2, 3]
```

16. 디폴트 딕셔너리(Default Dictionary)

디폴트 딕셔너리는 존재하지 않는 키에 대해 값을 지정해 놓을 수 있는 딕셔너리입니다. 존재하지 않는 키에 접근할 때마다 디폴트 값을 반환합니다. 파이썬에서는 collections 모듈의 defaultdict 클래스를 사용하여 구현할 수 있습니다.

예시:

```python
from collections import defaultdict

d = defaultdict(int)
d['apple'] += 1
d['banana'] += 2
print(d)  # defaultdict(<class 'int'>, {'apple': 1, 'banana': 2})
```

17. 카운터(Counter)

카운터는 시퀀스(문자열, 리스트 등)에 있는 각 요소의 개수를 셀 수 있는 딕셔너리의 서브 클래스입니다. 파이썬에서는 collections 모듈의 Counter 클래스를 사용하여 구현할 수 있습니다.

예시:

```python
from collections import Counter

c = Counter('hello, world')
print(c)  # Counter({'l': 3, 'o': 2, ' ': 2, 'e': 1, 'h': 1, ',': 1, 'w': 1, 'r': 1, 'd': 1})
```

18. 네임드 튜플(Named Tuple)

네임드 튜플은 튜플의 서브 클래스로, 각 요소에 이름을 지정할 수 있습니다. 각 요소에 대한 이름이 명시적으로 지정되므로, 코드의 가독성을 높일 수 있습니다. 파이썬에서는 collections 모듈의 namedtuple 함수를 사용하여 구현할 수 있습니다.

예시:

```python

```
